/**
 * Orchestrator Service Interfaces
 *
 * Defines the contracts for the meta-orchestrator that uses Claude CLI + MCP
 * to control the canvas through natural language.
 */

// =============================================================================
// Core Types
// =============================================================================

/**
 * Represents a tool call made during assistant response
 */
export interface ToolCall {
  id: string;
  name: string;
  input: Record<string, unknown>;
  result?: unknown;
}

/**
 * A conversation with the orchestrator
 */
export interface OrchestratorConversation {
  id: string;
  createdAt: number;
  updatedAt: number;
}

/**
 * A message in an orchestrator conversation
 */
export interface OrchestratorMessage {
  id: string;
  conversationId: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  toolCalls?: ToolCall[];
}

/**
 * Health status of the orchestrator
 */
export interface OrchestratorHealth {
  cliAvailable: boolean;
  lastHealthCheck: number;
}

/**
 * Response from sending a message
 */
export interface OrchestratorResponse {
  content: string;
  toolCalls?: ToolCall[];
}

/**
 * Callback for streaming response chunks
 */
export type StreamCallback = (chunk: string) => void;

// =============================================================================
// Service Interfaces
// =============================================================================

/**
 * Main orchestrator service interface
 *
 * Responsible for:
 * - Managing conversations and messages
 * - Spawning Claude CLI with MCP config
 * - Parsing JSON output and streaming responses
 * - Persisting conversations to SQLite
 */
export interface IOrchestratorService {
  /**
   * Initialize the service (start MCP server, etc.)
   */
  initialize(): Promise<void>;

  /**
   * Get the health status of the orchestrator
   */
  getHealth(): Promise<OrchestratorHealth>;

  /**
   * Send a message and get a response
   * @param conversationId - The conversation to send to
   * @param message - The user message
   * @param onChunk - Optional callback for streaming response chunks
   */
  sendMessage(
    conversationId: string,
    message: string,
    onChunk?: StreamCallback
  ): Promise<OrchestratorResponse>;

  /**
   * Get a conversation by ID
   */
  getConversation(id: string): Promise<OrchestratorConversation | null>;

  /**
   * Get the most recent conversation
   */
  getMostRecentConversation(): Promise<OrchestratorConversation | null>;

  /**
   * Create a new conversation
   */
  createConversation(): Promise<OrchestratorConversation>;

  /**
   * Get all messages in a conversation
   */
  getMessages(conversationId: string): Promise<OrchestratorMessage[]>;

  /**
   * Clean up resources
   */
  dispose(): void;
}

// =============================================================================
// Canvas State Provider Interface
// =============================================================================

/**
 * Summary of an agent on the canvas
 */
export interface AgentSummary {
  id: string;
  title: string;
  workspacePath: string;
  status?: string;
}

/**
 * Parameters for creating an agent
 */
export interface CreateAgentParams {
  workspacePath: string;
  title?: string;
  initialPrompt?: string;
}

/**
 * Provides access to canvas state for MCP tools
 *
 * This interface is implemented via IPC to query the renderer
 * process for current canvas state.
 */
export interface ICanvasStateProvider {
  /**
   * List all agents currently on the canvas
   */
  listAgents(): Promise<AgentSummary[]>;

  /**
   * Create a new agent on the canvas
   */
  createAgent(params: CreateAgentParams): Promise<{ agentId: string }>;

  /**
   * Delete an agent from the canvas
   */
  deleteAgent(agentId: string): Promise<void>;
}

// =============================================================================
// Database Extensions
// =============================================================================

/**
 * Input for adding a message (ID is generated by database)
 */
export interface AddOrchestratorMessageInput {
  conversationId: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  toolCalls?: ToolCall[];
}

/**
 * Database methods for orchestrator persistence
 * These should be added to IDatabase interface
 */
export interface IOrchestratorDatabase {
  createOrchestratorConversation(): Promise<OrchestratorConversation>;
  getOrchestratorConversation(id: string): Promise<OrchestratorConversation | null>;
  getMostRecentOrchestratorConversation(): Promise<OrchestratorConversation | null>;
  deleteOrchestratorConversation(id: string): Promise<void>;
  addOrchestratorMessage(input: AddOrchestratorMessageInput): Promise<OrchestratorMessage>;
  getOrchestratorMessages(conversationId: string): Promise<OrchestratorMessage[]>;
}
