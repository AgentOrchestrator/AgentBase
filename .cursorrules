# Cursor AI Rules for Agent Orchestrator

## Git Workflow

### Branch Management
- **Always create a new branch** for any code edits or features
- Branch naming convention: Use descriptive names (e.g., `feature/add-auth`, `fix/install-env-vars`, `refactor/cleanup-types`)
- **Never commit directly to main branch**
- After completing work, merge the branch with main before pushing
- Delete feature branches after successful merge to keep the repository clean

### Workflow Steps
1. Create a new branch: `git checkout -b <descriptive-branch-name>`
2. Make your changes and commit them
3. Switch to main: `git checkout main`
4. Merge your feature branch: `git merge <your-branch-name>`
5. Push to remote: `git push origin main`
6. Delete the feature branch: `git branch -d <your-branch-name>`

## Multi-Repo Structure
- This is a multi-repo setup with submodules
- Main submodules include: agent-orchestrator-daemon, web
- **IMPORTANT**: When making changes to files within a submodule:
  - Navigate to the submodule directory (e.g., `cd agent-orchestrator-daemon` or `cd web`)
  - Create branches, commit, and push from within that submodule
  - Do NOT commit submodule changes in the parent repository
- Only commit to the parent repository when:
  - Changing files directly in the parent (e.g., cli/, root config files)
  - Updating submodule references (after submodule has been pushed)
- When making changes across submodules, ensure commits are properly coordinated

## Code Standards
- Follow existing code conventions in the repository
- Ensure TypeScript types are properly defined
- Run tests before merging branches
- Update documentation when adding new features

## Next.js App Router Guidelines (for web submodule)

### Server vs Client Components
- **NEVER** add `'use client'` to a file that exports an async component
- Async components are Server Components and cannot be Client Components
- If you need both server-side data fetching AND client-side interactivity:
  1. Keep the page.tsx as a Server Component (no `'use client'`)
  2. Create a separate client component file for interactivity
  3. Server Component fetches data → passes props to Client Component

### When to Use 'use client'
- Only use `'use client'` when the component needs:
  - React hooks (useState, useEffect, useRef, etc.)
  - Browser APIs (IntersectionObserver, localStorage, etc.)
  - Event handlers (onClick, onChange, etc.)
- Prefer Server Components by default for better performance

### Component Architecture Pattern
```
page.tsx (Server Component - async, fetches data)
  ↓ passes data as props
client-wrapper.tsx ('use client' - handles interactivity)
  ↓ renders
ui-component.tsx ('use client' if needed - displays UI)
```

### Common Error to Avoid
❌ **WRONG:**
```tsx
'use client';  // ← Error: async component in client file
export default async function Page() { ... }
```

✅ **CORRECT:**
```tsx
// page.tsx (no 'use client')
export default async function Page() {
  const data = await fetchData();
  return <ClientWrapper data={data} />;
}

// client-wrapper.tsx
'use client';
export function ClientWrapper({ data }) { ... }
```
