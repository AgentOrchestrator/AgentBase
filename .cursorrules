# Cursor AI Rules for Agent Orchestrator

## Git Workflow

### Branch Management
- **Always create a new branch** for any code edits or features
- Branch naming convention: Use descriptive names (e.g., `feature/add-auth`, `fix/install-env-vars`, `refactor/cleanup-types`)
- **NEVER commit directly to main branch**
- **NEVER push directly to main branch**
- **Always create a Pull Request** for code review before merging
- Delete feature branches after successful merge to keep the repository clean

### Workflow Steps
1. Create a new branch: `git checkout -b <descriptive-branch-name>`
2. Make your changes and commit them
3. **Before pushing, merge main into your branch:**
   ```bash
   git fetch origin main
   git merge origin/main
   # Resolve any conflicts if they occur
   ```
4. Push your feature branch: `git push -u origin <your-branch-name>`
5. Create a Pull Request (PR) to merge into main
6. Wait for code review and approval
7. Merge the PR on GitHub (or via `gh` CLI)
8. **After PR is merged, clean up locally:**
   ```bash
   git checkout main
   git pull origin main
   git branch -d <your-branch-name>
   ```
9. **Important:** Always delete your local feature branch after the PR is merged to keep your workspace clean

### Pull Request Guidelines
- Write clear PR titles and descriptions
- Reference any related issues
- Ensure all tests pass before requesting review
- Respond to review comments promptly
- Keep PRs focused on a single feature or fix

## Multi-Repo Structure
- This is a multi-repo setup with submodules
- Main submodules include: agent-orchestrator-daemon, web
- **IMPORTANT**: When making changes to files within a submodule:
  - Navigate to the submodule directory (e.g., `cd agent-orchestrator-daemon` or `cd web`)
  - Create branches, commit, and push from within that submodule
  - Do NOT commit submodule changes in the parent repository
- Only commit to the parent repository when:
  - Changing files directly in the parent (e.g., cli/, root config files)
  - Updating submodule references (after submodule has been pushed)
- When making changes across submodules, ensure commits are properly coordinated

## Code Standards
- Follow existing code conventions in the repository
- Ensure TypeScript types are properly defined
- Run tests before merging branches
- Update documentation when adding new features

## Next.js App Router Guidelines (for web submodule)

### Server vs Client Components
- **NEVER** add `'use client'` to a file that exports an async component
- Async components are Server Components and cannot be Client Components
- If you need both server-side data fetching AND client-side interactivity:
  1. Keep the page.tsx as a Server Component (no `'use client'`)
  2. Create a separate client component file for interactivity
  3. Server Component fetches data → passes props to Client Component

### When to Use 'use client'
- Only use `'use client'` when the component needs:
  - React hooks (useState, useEffect, useRef, etc.)
  - Browser APIs (IntersectionObserver, localStorage, etc.)
  - Event handlers (onClick, onChange, etc.)
- Prefer Server Components by default for better performance

### Component Architecture Pattern
```
page.tsx (Server Component - async, fetches data)
  ↓ passes data as props
client-wrapper.tsx ('use client' - handles interactivity)
  ↓ renders
ui-component.tsx ('use client' if needed - displays UI)
```

### Common Error to Avoid
❌ **WRONG:**
```tsx
'use client';  // ← Error: async component in client file
export default async function Page() { ... }
```

✅ **CORRECT:**
```tsx
// page.tsx (no 'use client')
export default async function Page() {
  const data = await fetchData();
  return <ClientWrapper data={data} />;
}

// client-wrapper.tsx
'use client';
export function ClientWrapper({ data }) { ... }
```

## Environment Variables & Server-Only Code

### Critical: Separate Server-Only Modules
**PROBLEM:** Module-level code in Next.js runs on BOTH client and server during bundling, even in Server Components.

**SOLUTION:** Keep server-only code (admin clients, service keys) in separate files imported ONLY by server code.

### Quick Rule
- ❌ **WRONG:** Mixing public and admin clients in one file → Client bundle tries to access server-only env vars
- ✅ **CORRECT:** Separate files (`lib/supabase.ts` vs `lib/supabase-admin.ts`) → Server-only file never bundled for client

### File Naming Convention
- `*-admin.ts` → Server-only (admin/service role operations)
- `*-server.ts` → Server-only (private server logic)
- Regular files → Can be used anywhere (public env vars only)

### Environment Variable Rules
- `NEXT_PUBLIC_*` → Exposed to client (safe for public keys)
- `SUPABASE_SERVICE_ROLE_KEY` → Server-only (NEVER use NEXT_PUBLIC_ prefix)
- API routes → Can use any env var (always server-side)

## Database Migrations (Supabase)

### Critical Rule: Always Create Migration Files First
**NEVER** apply migrations directly using MCP tools without creating local migration files first.

### Migration Workflow
1. **Generate migration file:**
   ```bash
   npx supabase migration new <descriptive_name>
   ```

2. **Write SQL in the file:**
   - Add comments explaining changes
   - Include RLS policies for new tables
   - Verify foreign key references

3. **Review before applying:**
   - Check syntax and typos
   - Ensure security policies are included
   - Test locally when possible

4. **Apply migration:**
   ```bash
   npx supabase db push
   # OR use MCP tool only after file exists
   ```

5. **Verify:**
   - Check tables created correctly
   - Test RLS policies
   - Run security advisors

### Best Practices
- One migration per logical change
- Include rollback comments
- Never hardcode IDs in migrations
- Always add RLS policies for new tables
- Migration files are timestamped: `YYYYMMDDHHMMSS_name.sql`
